defmodule Autumn.ThemesGenerator do
  @moduledoc false

  @semicolon ?;
  @default_fg_color "#000000"
  @default_bg_color "#ffffff"
  @id "ahl"

  @themes_rs_template ~S"""
  //
  // DO NOT EDIT THIS FILE
  //
  // Generated automatically by mix task `Mix.Tasks.Autumn.GenerateThemes`.
  // Execute `mix autumn.generate_themes_rs` at the root to update this file.
  //
  // Generated at <%= DateTime.utc_now() %>

  #![allow(dead_code)]
  #![allow(unused_variables)]

  use phf::phf_map;

  pub const HIGHLIGHT_CLASS_NAMES: &[&str] = &[
      "ahl-attribute",
      "ahl-type",
      "ahl-type ahl-builtin",
      "ahl-type ahl-enum",
      "ahl-type ahl-enum variant",
      "ahl-constructor",
      "ahl-constant",
      "ahl-constant ahl-builtin",
      "ahl-constant ahl-builtin boolean",
      "ahl-constant ahl-character",
      "ahl-constant ahl-character escape",
      "ahl-constant ahl-numeric",
      "ahl-constant ahl-numeric integer",
      "ahl-constant ahl-numeric float",
      "ahl-string",
      "ahl-string ahl-regexp",
      "ahl-string ahl-special",
      "ahl-string ahl-special ahl-path",
      "ahl-string ahl-special ahl-url",
      "ahl-string ahl-special ahl-symbol",
      "ahl-escape",
      "ahl-comment",
      "ahl-comment ahl-line",
      "ahl-comment ahl-block",
      "ahl-comment ahl-block ahl-documentation",
      "ahl-variable",
      "ahl-variable ahl-builtin",
      "ahl-variable ahl-parameter",
      "ahl-variable ahl-other",
      "ahl-variable ahl-other ahl-member",
      "ahl-label",
      "ahl-punctuation",
      "ahl-punctuation ahl-delimiter",
      "ahl-punctuation ahl-bracket",
      "ahl-punctuation ahl-special",
      "ahl-keyword",
      "ahl-keyword ahl-control",
      "ahl-keyword ahl-control ahl-conditional",
      "ahl-keyword ahl-control ahl-repeat",
      "ahl-keyword ahl-control ahl-import",
      "ahl-keyword ahl-control ahl-return",
      "ahl-keyword ahl-control ahl-exception",
      "ahl-keyword ahl-operator",
      "ahl-keyword ahl-directive",
      "ahl-keyword ahl-function",
      "ahl-keyword ahl-storage",
      "ahl-keyword ahl-storage ahl-type",
      "ahl-keyword ahl-storage ahl-modifier",
      "ahl-operator",
      "ahl-function",
      "ahl-function ahl-builtin",
      "ahl-function ahl-method",
      "ahl-function ahl-macro",
      "ahl-function ahl-special",
      "ahl-tag",
      "ahl-tag ahl-builtin",
      "ahl-namespace",
      "ahl-special",
      "ahl-markup",
      "ahl-markup ahl-heading",
      "ahl-markup ahl-heading ahl-marker",
      "ahl-markup ahl-heading ahl-1",
      "ahl-markup ahl-heading ahl-2",
      "ahl-markup ahl-heading ahl-3",
      "ahl-markup ahl-heading ahl-4",
      "ahl-markup ahl-heading ahl-5",
      "ahl-markup ahl-heading ahl-6",
      "ahl-markup ahl-list",
      "ahl-markup ahl-list ahl-unnumbered",
      "ahl-markup ahl-list ahl-numbered",
      "ahl-markup ahl-list ahl-checked",
      "ahl-markup ahl-list ahl-unchecked",
      "ahl-markup ahl-bold",
      "ahl-markup ahl-italic",
      "ahl-markup ahl-strikethrough",
      "ahl-markup ahl-link",
      "ahl-markup ahl-link ahl-url",
      "ahl-markup ahl-link ahl-label",
      "ahl-markup ahl-link ahl-text",
      "ahl-markup ahl-quote",
      "ahl-markup ahl-raw",
      "ahl-markup ahl-raw ahl-inline",
      "ahl-markup ahl-raw ahl-block",
      "ahl-diff",
      "ahl-diff ahl-plus",
      "ahl-diff ahl-minus",
      "ahl-diff ahl-delta",
      "ahl-diff ahl-delta ahl-moved",
  ];

  #[derive(Debug)]
  pub struct Theme {
      pub global: phf::Map<&'static str, &'static str>,
      pub scopes: phf::Map<&'static str, &'static str>
  }

  impl Theme {
      pub fn get_global_style(&self, scope: &str) -> &str {
          self.global.get(scope).unwrap()
      }

      pub fn get_style(&self, scope: &str) -> &str {
          match self.scopes.get(scope) {
              Some(style) => style,
              None => {
                  if scope.contains('.') {
                      let split: Vec<&str> = scope.split('.').collect();
                      let joined = split[0..split.len() - 1].join(".");
                      self.get_style(joined.as_str())
                  } else {
                      self.get_global_style("foreground")
                  }
              }
          }
      }
  }

  static THEMES: phf::Map<&'static str, Theme> = phf_map! {<%= for {theme, %{"global" => global, "scopes" => scopes}} <- @themes do %>
      "<%= theme %>" => Theme {
          global: phf_map! {<%= for {name, style} <- global do %>
              "<%= name %>" => "<%= style %>",<% end %>
          },
          scopes: phf_map! {<%= for {scope, %{"style" => style}} <- scopes do %>
            "<%= scope %>" => "<%= style %>",<% end %>
          },
      },<% end %>
  };

  pub fn theme(name: &str) -> Option<&Theme> {
      THEMES.get(name)
  }

  #[cfg(test)]
  mod tests {
      use super::*;
      <%= for {theme, _scopes} <- @themes do %>
      #[test]
      fn load_<%= theme %>() {
          let _theme = theme("<%= theme %>");
      }<% end %>
  }
  """

  def parse_theme_file(path) when is_binary(path) do
    {:ok, scopes} = Toml.decode_file(path)
    {palette, scopes} = Map.pop(scopes, "palette", %{})
    {inherits, scopes} = Map.pop(scopes, "inherits", "")

    {parent_palette, parent_scopes} =
      path
      |> parent_theme_file(inherits)
      |> Map.pop("palette", %{})

    name =
      path
      |> Path.basename(".toml")
      |> String.replace(" ", "_")
      |> String.replace("-", "_")
      |> String.replace("+", "")

    palette = Map.merge(parent_palette, palette)
    scopes = Map.merge(parent_scopes, scopes)

    %{"name" => name, "scopes" => scopes, "palette" => palette}
  end

  defp parent_theme_file(path, inherits) do
    path = Path.join(Path.dirname(path), "#{inherits}.toml")
    if File.exists?(path), do: Toml.decode_file!(path), else: %{}
  end

  def expand_theme(theme) do
    scopes = Map.get(theme, "scopes", %{})
    palette = Map.get(theme, "palette", %{})

    foreground_style = scopes |> foreground_style(palette) |> IO.iodata_to_binary()
    background_style = scopes |> background_style(palette) |> IO.iodata_to_binary()

    scopes =
      scopes
      |> Enum.to_list()
      |> expand_scope(palette, %{})

    %{
      "global" => %{"foreground" => foreground_style, "background" => background_style},
      "scopes" => scopes
    }
  end

  defp expand_scope([], _palette, acc), do: acc

  defp expand_scope([{<<"ui."::binary, _::binary>>, _attrs} | rest], palette, acc),
    do: expand_scope(rest, palette, acc)

  defp expand_scope([{scope, attrs} | rest], palette, acc) do
    acc =
      case style(palette, attrs) do
        "" ->
          acc

        style ->
          rule = scope |> String.split(".") |> Enum.map(&"#{@id}-#{&1}") |> Enum.join(".")

          Map.put(acc, scope, %{
            "rule" => ".#{rule}",
            "style" => style
          })
      end

    expand_scope(rest, palette, acc)
  end

  defp parse_themes(src_path) do
    src_path
    |> Path.join("*.toml")
    |> Path.wildcard()
    |> Enum.reduce(%{}, fn theme_file, acc ->
      %{"name" => name} = theme = parse_theme_file(theme_file)
      Map.put(acc, name, expand_theme(theme))
    end)
  end

  def generate_themes_rs(
        src_path \\ Path.join(:code.priv_dir(:autumn), "themes"),
        dest_path \\ Path.join([File.cwd!(), "native", "autumn", "src", "themes.rs"])
      ) do
    themes = parse_themes(src_path)
    themes_rs = EEx.eval_string(@themes_rs_template, assigns: %{themes: themes})
    File.write!(dest_path, themes_rs)
    themes
  end

  def generate_css(
        src_path \\ Path.join(:code.priv_dir(:autumn), "themes"),
        dest_path \\ Path.join([:code.priv_dir(:autumn), "static", "css"])
      ) do
    File.mkdir_p!(dest_path)
    themes = parse_themes(src_path)

    Enum.reduce(themes, %{}, fn {theme, %{"global" => global, "scopes" => scopes}}, acc ->
      path = Path.join(dest_path, "#{theme}.css")
      scopes = Enum.to_list(scopes)

      header =
        [
          "/* ",
          theme,
          " */",
          "\n",
          "pre.autumn-hl { ",
          global["background"],
          " ",
          global["foreground"],
          " }\n"
        ]

      css = [header, css_style(scopes, [])]
      File.write!(path, css)

      Map.put(acc, theme, IO.iodata_to_binary(css))
    end)
  end

  defp css_style([], acc), do: acc

  defp css_style([scope | rest], acc) do
    {_, %{"rule" => rule, "style" => style}} = scope
    css = [rule, " { ", style, " }\n"]
    css_style(rest, [acc | css])
  end

  defp foreground_style(%{"text" => %{"fg" => fg}}, palette), do: fg(palette, fg)
  defp foreground_style(%{"text" => fg}, palette) when is_binary(fg), do: fg(palette, fg)
  defp foreground_style(%{"ui.text" => %{"fg" => fg}}, palette), do: fg(palette, fg)
  defp foreground_style(%{"ui.text" => fg}, palette) when is_binary(fg), do: fg(palette, fg)
  defp foreground_style(_scopes, palette), do: fg(palette, @default_fg_color)

  defp background_style(%{"background" => %{"bg" => bg}}, palette), do: bg(palette, bg)
  defp background_style(%{"background" => bg}, palette) when is_binary(bg), do: bg(palette, bg)
  defp background_style(%{"ui.background" => %{"bg" => bg}}, palette), do: bg(palette, bg)
  defp background_style(%{"ui.background" => bg}, palette) when is_binary(bg), do: bg(palette, bg)
  defp background_style(%{"ui.window" => %{"bg" => bg}}, palette), do: bg(palette, bg)
  defp background_style(_scopes, palette), do: bg(palette, @default_bg_color)

  # https://docs.helix-editor.com/themes.html#color-palettes
  defp palette_color(palette, color_name), do: Map.get(palette, color_name, color_name)

  defp style(_palette, <<"#"::binary, _rest::binary>> = color) do
    IO.iodata_to_binary(["color: ", color, @semicolon])
  end

  defp style(palette, fg) when is_binary(fg) do
    IO.iodata_to_binary(["color: ", palette_color(palette, fg), @semicolon])
  end

  defp style(palette, style) when is_map(style) do
    style
    |> Enum.reduce([], fn
      {"fg", fg}, acc ->
        [fg(palette, fg) | acc]

      {"bg", bg}, acc ->
        [bg(palette, bg) | acc]

      {"modifiers", modifiers}, acc ->
        [modifiers(modifiers) | acc]

      {"underline", underline}, acc ->
        [underline(palette, underline) | acc]

      # TODO: support all style keys
      _style, acc ->
        acc
    end)
    |> Enum.join(" ")
  end

  defp fg(_palette, <<"#"::binary, _rest::binary>> = fg) do
    ["color: ", fg, @semicolon]
  end

  defp fg(palette, fg) do
    ["color: ", palette_color(palette, fg), @semicolon]
  end

  defp bg(_palette, <<"#"::binary, _rest::binary>> = bg) do
    ["background-color: ", bg, @semicolon]
  end

  defp bg(palette, bg) do
    ["background-color: ", palette_color(palette, bg), @semicolon]
  end

  # https://docs.helix-editor.com/themes.html#modifiers
  defp modifiers(modifiers) do
    Enum.reduce(modifiers, [], fn
      "underline", acc ->
        ["text-decoration: underline;" | acc]

      "italic", acc ->
        ["font-style: italic;" | acc]

      "bold", acc ->
        ["font-weight: bold;" | acc]

      # TODO: support all modifiers
      _modifier, acc ->
        acc
    end)
  end

  # https://docs.helix-editor.com/themes.html#underline-style
  defp underline(palette, underline) do
    Enum.reduce(underline, [], fn
      {"color", color}, acc ->
        [fg(palette, color) | acc]

      {"style", "line"}, acc ->
        ["text-decoration: underline;" | acc]

      # TODO: support all underline styles
      {"style", _style}, acc ->
        acc
    end)
  end
end
